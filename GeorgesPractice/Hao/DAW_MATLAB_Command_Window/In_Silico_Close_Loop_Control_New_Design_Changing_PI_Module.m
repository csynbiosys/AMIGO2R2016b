% In this design, input u is generated by IRMA model, output is then
% compared to model result, to generate an error, added to the input. 

clear all; clc;
% Parameters for IRMA
load K;
load y0glu;
y0_for_Sim=y0;

% Experiment start
Experiment_Length=1800; % min

% Load reference ouput r
% Control output y from t=1~1000min
% Specified output is r
%r(1:300)=0.6; r(301:600)=0.6; r(601:1120)=0.6;
r(1:1000)=linspace(0,1,1000); r(1001:2000)=linspace(1,0,1000); 



% Set parameters
Normalize_Factor_Segmentation = 0.046735005043180;
Normalize_Factor_IRMA         = 0.046735005043180;
% Pre allocation for speed
Normalized_Fluo_Out=zeros(1,Experiment_Length);
Denormalized_Error=zeros(1,Experiment_Length);
Denormalized_Error_Added_to_Input=zeros(1,Experiment_Length);
Cumulative_Error=0;
u=zeros(1,Experiment_Length);
Actual_Input_Record=zeros(1,Experiment_Length);

% Input to reverse IRMA model
Denormalized_Input_to_IRMA=r*Normalize_Factor_IRMA;

% For simultion
yout=zeros(1,1000);
yout(1)=y0_for_Sim(1);

% PI controller parameters
Kp=0.5; Ki=0.5;
load new_y0_math_model;
for Time=1:Experiment_Length
    fprintf('Experiment Time = %d min\n',Time);
    % Check for New files and segment to give fluorescence output
    % ExistNewFile=NewFile_Detect_and_Segment(Auto_Detect_Directory,Mask);
    % Testing purpose
    Fluorescence_Record=yout(Time)-0.004;

    %% Normalization & Compute error e
    Normalized_Fluo_Out(Time)=Fluorescence_Record/Normalize_Factor_Segmentation;
    % Math_model-actual fluo output
    Denormalized_Error(Time)=y0_math_model(Time)-Fluorescence_Record;
    Error_Reevaluaing_index=floor((Time-1)/200)*200;
    % Starting_Point for Denormalized_Error_Added_to_Input
    if Time<51  
        Starting_Point=1;
    else
        Starting_Point=Time-50;
    end
    Denormalized_Error_Added_to_Input(Time)=mean(Denormalized_Error(Starting_Point:Time));
    %% PI controller
    if (rem(Time,200)==0)
        Cumulative_Error=Cumulative_Error+Ki*mean(Denormalized_Error(Error_Reevaluaing_index+1:Time));
    end
    
    %% estimate correct input using IRMA
    Actual_Input=Denormalized_Input_to_IRMA(Time+120)+Kp*Denormalized_Error_Added_to_Input(Time)+Cumulative_Error;
    Actual_Input_Record(Time)=Actual_Input;
    
    % What if u is 1
    sol_high = dde23(@(t,sol,Z) IRMA5b(t,sol,Z,K,1,0,t), 100 ,y0,[Time Time+1]);
    sol_high_delay = dde23(@(t,sol,Z) IRMA5b(t,sol,Z,K,1,0,t), 100 ,y0,[Time Time+120]);
    yout_high=sol_high_delay.y(1,end);

    % What if u is 0
    sol_low = dde23(@(t,sol,Z) IRMA5b(t,sol,Z,K,0,0,t), 100 ,y0,[Time Time+1]);
    sol_low_delay = dde23(@(t,sol,Z) IRMA5b(t,sol,Z,K,0,0,t), 100 ,y0,[Time Time+120]);
    yout_low=sol_low_delay.y(1,end);

    % Now choose a u that most closly suit r
    if (    round((abs(yout_high-Actual_Input)),4) <=   round((abs(yout_low-Actual_Input)),4)   )
        u(Time)=1;
        y0=sol_high;
    else
        u(Time)=0;
        y0=sol_low;        
    end


    %% Send input to actuators
    %{
    Gal_Axis=1;
    Glu_Axis=2;
    if (u(Time)==1)
        Write_Target_Position(80000,1);
        Write_Target_Position(0,2);
    else
        Write_Target_Position(0,1);
        Write_Target_Position(80000,2);        
    end
    %}
    
    %% Use IRMA model to simuate
    sol = dde23(@(t,sol,Z) IRMA5b(t,sol,Z,K,u(Time),0,t), 100 ,y0_for_Sim,[Time Time+1]);
    y0_for_Sim=sol;
    yout(Time+1)=sol.y(1,end);
end
Actual_Input_Record_Shifted=[Denormalized_Input_to_IRMA(1:120),Actual_Input_Record];
x=1:Experiment_Length;
hold on;
%plot(x,y0_math_model(1:Experiment_Length));
%plot(x,r(1:1000));
plot(x,Denormalized_Input_to_IRMA(1:Experiment_Length));
plot(x,yout(1:Experiment_Length));
%plot(x,Normalized_Fluo_Out);    
plot(x,Actual_Input_Record_Shifted(1:Experiment_Length));
%plot(x,Denormalized_Error_Added_to_Input);